#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

//表达式求值
//表达式求值的顺序，一部分是由操作符的优先级和结合性决定。
//同样，有些表达式的操作数在求值的过程中可能需要转换为其他类型。

//int main()
//{
//	int a = 2 + 6 / 3;//先比较表达式中操作符优先级
//	int b = 2 + 1 + 3;//优先级相同，看结合性
//	return 0;
//}

//隐式类型转换
//C的整型算术运算总是至少以缺省（默认）整型类型的精度来进行的
//为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转换为普通整型，这种转换称为整型提升。

//int main()
//{
//	//对于有符号的字符类型
//	char c = -1;//-1是整数，32个比特位
//	//10000000000000000000000000000001
//	//11111111111111111111111111111111->-1的补码
//	//因为是char类型，c只占一个字节
//	//故11111111->c（截断了）
//	//负数c整型提升为11111111111111111111111111111111（负数就在前面补1）
//	//正数就在前面补0
//	printf("%d\n", c);
//	return 0;
//}

//int main()
//{
//	char a = 5;
//	//00000000000000000000000000000101
//	//00000101->a(此时a放的是这个二进制位)
//	//对于有符号数来说
//	//这时一个正数
//	char b = 126;
//	//00000000000000000000000011111110
//	//01111110->b
//	char c = a + b;
//	//a + b
//	//此时a和b达不到一个整型大小
//	//这时就会发生整型提升
//	//整型提升是按照变量的数据类型的符号位来提升的
//	//00000000000000000000000000000101->a
//	//00000000000000000000000001111110->b
//	//00000000000000000000000010000011->a + b
//	//10000011->c
//	printf("%d\n", c);
//	//打印时发生整型提升
//	//11111111111111111111111110000011-补码
//	//10000000000000000000000001111101-原码
//	return 0;
//}
//整型提升的意义：
//表达式的整型运算要在CPU的相应运算器件内执行，CPU内
//整型运算器（ALU）的操作数的字节长度一般就是int的字节长度，
//同时也是CPU的通用寄存器的长度。
//因此，即使两个char类型的相加，在CPU执行时实际上也要
//先转换为CPU内整型操作数的标准长度。

//算术转换
//如果某个操作符的各个操作数属于不同的类型，那么除非其中一个
//操作数的转换为另一个操作数的类型，否则操作就无法进行。
//需要进行寻常算术转换
//如果某个操作数的类型在列表中排名较低，那么首先要转换为
//另一个操作数的类型后执行运算

//两个相邻的操作符先执行哪个？取决于他们的优先级。
//注意这里是指相邻操作符
//如果两者的优先级相同，取决于他们的结合性。
//是否对求值结果有影响
//例如&&、||、条件操作符以及逗号等，左边为假或者其他情况，右边就不再不需要计算
//写出的代码要有唯一确定的路径

//int main()
//{
//	int a = 1;
//	int b = (++a) + (++a) + (++a);
//	printf("%d\n", b);
//	return 0;
//}//学会调试看汇编,还是挺有意思的